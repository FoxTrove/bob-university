#!/usr/bin/env node

/**
 * Generate TypeScript types from Supabase schema JSON
 *
 * Usage:
 *   1. Run the SQL query in scripts/get-schema.sql in Supabase SQL Editor
 *   2. Copy the results as JSON
 *   3. Save to a file (e.g., schema-data.json)
 *   4. Run: node scripts/schema-from-json.js schema-data.json
 *
 * Or pipe the JSON directly:
 *   cat schema-data.json | node scripts/schema-from-json.js
 */

const fs = require('fs');

function mapPostgresTypeToTS(dataType, udtName, isNullable) {
  const nullable = isNullable === 'YES' ? ' | null' : '';

  const typeMap = {
    'bigint': 'number',
    'int8': 'number',
    'integer': 'number',
    'int': 'number',
    'int4': 'number',
    'smallint': 'number',
    'int2': 'number',
    'numeric': 'number',
    'decimal': 'number',
    'real': 'number',
    'float4': 'number',
    'double precision': 'number',
    'float8': 'number',
    'text': 'string',
    'varchar': 'string',
    'character varying': 'string',
    'char': 'string',
    'character': 'string',
    'uuid': 'string',
    'boolean': 'boolean',
    'bool': 'boolean',
    'date': 'string',
    'timestamp': 'string',
    'timestamp without time zone': 'string',
    'timestamp with time zone': 'string',
    'timestamptz': 'string',
    'time': 'string',
    'json': 'Record<string, any>',
    'jsonb': 'Record<string, any>',
    'array': 'any[]',
    'bytea': 'string',
    'USER-DEFINED': 'string', // Usually enums, would need more info
  };

  let tsType = typeMap[dataType] || typeMap[udtName] || 'any';

  // Handle arrays
  if (udtName && udtName.startsWith('_')) {
    tsType = 'any[]';
  }

  return tsType + nullable;
}

function generateTypeScriptTypes(schemaData) {
  const tableMap = {};

  // Group columns by table
  schemaData.forEach(col => {
    if (!tableMap[col.table_name]) {
      tableMap[col.table_name] = [];
    }
    tableMap[col.table_name].push(col);
  });

  let output = '// Generated TypeScript types from Supabase database schema\n';
  output += '// Generated at: ' + new Date().toISOString() + '\n';
  output += '// \n';
  output += '// This file defines the database schema types for the Bob University app.\n';
  output += '// These types should match the Supabase database schema exactly.\n\n';

  // Generate Database namespace
  output += 'export type Json =\n';
  output += '  | string\n';
  output += '  | number\n';
  output += '  | boolean\n';
  output += '  | null\n';
  output += '  | { [key: string]: Json | undefined }\n';
  output += '  | Json[]\n\n';

  output += 'export interface Database {\n';
  output += '  public: {\n';
  output += '    Tables: {\n';

  // Generate types for each table
  Object.keys(tableMap).sort().forEach(tableName => {
    const columns = tableMap[tableName];

    output += `      ${tableName}: {\n`;
    output += '        Row: {\n';

    columns.forEach(col => {
      const tsType = mapPostgresTypeToTS(col.data_type, col.udt_name, col.is_nullable);
      const comment = col.is_primary_key === 'YES' ? ' // Primary Key' : '';
      const fkComment = col.foreign_key_reference ? ` // FK -> ${col.foreign_key_reference}` : '';
      output += `          ${col.column_name}: ${tsType};${comment}${fkComment}\n`;
    });

    output += '        }\n';
    output += '        Insert: {\n';

    columns.forEach(col => {
      // For insert, make auto-generated columns optional
      const isAutoGenerated = col.column_default !== null || col.is_identity === 'YES';
      const isNullable = col.is_nullable === 'YES';
      let tsType = mapPostgresTypeToTS(col.data_type, col.udt_name, col.is_nullable);

      if (isAutoGenerated || isNullable) {
        // Remove the ' | null' if present and add '?' to make it optional
        tsType = tsType.replace(' | null', '');
        output += `          ${col.column_name}?: ${tsType}${isNullable ? ' | null' : ''};\n`;
      } else {
        output += `          ${col.column_name}: ${tsType};\n`;
      }
    });

    output += '        }\n';
    output += '        Update: {\n';

    columns.forEach(col => {
      let tsType = mapPostgresTypeToTS(col.data_type, col.udt_name, col.is_nullable);
      tsType = tsType.replace(' | null', '');
      const isNullable = col.is_nullable === 'YES';
      output += `          ${col.column_name}?: ${tsType}${isNullable ? ' | null' : ''};\n`;
    });

    output += '        }\n';
    output += '        Relationships: []\n';
    output += '      }\n';
  });

  output += '    }\n';
  output += '    Views: {}\n';
  output += '    Functions: {}\n';
  output += '    Enums: {}\n';
  output += '    CompositeTypes: {}\n';
  output += '  }\n';
  output += '}\n\n';

  // Add helper types
  output += '// Helper types for easier access\n';
  Object.keys(tableMap).sort().forEach(tableName => {
    const typeName = tableName
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');

    output += `export type ${typeName} = Database['public']['Tables']['${tableName}']['Row'];\n`;
    output += `export type ${typeName}Insert = Database['public']['Tables']['${tableName}']['Insert'];\n`;
    output += `export type ${typeName}Update = Database['public']['Tables']['${tableName}']['Update'];\n`;
  });

  return output;
}

function main() {
  let schemaJson;
  const args = process.argv.slice(2);

  if (args.length > 0) {
    // Read from file
    const filePath = args[0];
    try {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      schemaJson = JSON.parse(fileContent);
    } catch (error) {
      console.error(`Error reading file ${filePath}:`, error.message);
      process.exit(1);
    }
  } else {
    // Read from stdin
    console.error('Please provide a JSON file as argument or pipe JSON to stdin');
    console.error('Usage: node scripts/schema-from-json.js schema-data.json');
    console.error('   or: cat schema-data.json | node scripts/schema-from-json.js');
    process.exit(1);
  }

  if (!Array.isArray(schemaJson) || schemaJson.length === 0) {
    console.error('Error: Expected JSON array with schema data');
    process.exit(1);
  }

  const tsTypes = generateTypeScriptTypes(schemaJson);

  // Write to file
  const outputPath = 'lib/database.types.ts';
  fs.writeFileSync(outputPath, tsTypes);

  console.log('TypeScript types generated successfully!');
  console.log(`Output written to: ${outputPath}`);
  console.log('');
  console.log('Tables processed:');
  const tables = [...new Set(schemaJson.map(row => row.table_name))];
  tables.forEach(table => {
    const colCount = schemaJson.filter(row => row.table_name === table).length;
    console.log(`  - ${table} (${colCount} columns)`);
  });
}

if (require.main === module) {
  main();
}
